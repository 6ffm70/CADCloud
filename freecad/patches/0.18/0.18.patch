--- src/Mod/Part/App/Geometry2d.cpp	2020-06-29 22:29:42.741521637 +0000
+++ ../new/src/Mod/Part/App/Geometry2d.cpp	2020-06-29 14:22:55.000000000 +0000
@@ -83,7 +83,6 @@
 #include <Mod/Part/App/Geom2d/OffsetCurve2dPy.h>
 
 using namespace Part;
-using namespace std;
 
 extern const char* gce_ErrorStatusText(gce_ErrorType et);
 
@@ -184,7 +183,7 @@
         << "<Geom2dPoint "
         << "X=\"" << Point.x << "\" "
         << "Y=\"" << Point.y << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dPoint::Restore(Base::XMLReader &reader)
@@ -466,7 +465,7 @@
 
     for (Standard_Integer i=p.Lower(); i<=p.Upper(); i++) {
         const gp_Pnt2d& pnt = p(i);
-        poles.emplace_back(pnt.X(), pnt.Y());
+        poles.push_back(Base::Vector2d(pnt.X(), pnt.Y()));
     }
     return poles;
 }
@@ -876,7 +875,7 @@
     SaveAxis(writer, axis);
     writer.Stream()
         << "Radius=\"" << c.Radius() << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dCircle::Restore(Base::XMLReader& reader)
@@ -991,7 +990,7 @@
     SaveAxis(writer, axis, u, v);
     writer.Stream()
         << "Radius=\"" << c.Radius() << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dArcOfCircle::Restore(Base::XMLReader &reader)
@@ -1153,7 +1152,7 @@
     writer.Stream()
         << "MajorRadius=\"" << e.MajorRadius() << "\" "
         << "MinorRadius=\"" << e.MinorRadius() << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dEllipse::Restore(Base::XMLReader& reader)
@@ -1330,7 +1329,7 @@
     writer.Stream()
         << "MajorRadius=\"" << e.MajorRadius() << "\" "
         << "MinorRadius=\"" << e.MinorRadius() << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dArcOfEllipse::Restore(Base::XMLReader &reader)
@@ -1459,7 +1458,7 @@
     writer.Stream()
         << "MajorRadius=\"" <<  h.MajorRadius() << "\" "
         << "MinorRadius=\"" <<  h.MinorRadius() << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dHyperbola::Restore(Base::XMLReader& reader)
@@ -1592,7 +1591,7 @@
     writer.Stream()
         << "MajorRadius=\"" <<  h.MajorRadius() << "\" "
         << "MinorRadius=\"" <<  h.MinorRadius() << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dArcOfHyperbola::Restore(Base::XMLReader &reader)
@@ -1703,7 +1702,7 @@
     SaveAxis(writer, axis);
     writer.Stream()
         << "Focal=\"" << focal << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dParabola::Restore(Base::XMLReader& reader)
@@ -1816,7 +1815,7 @@
     SaveAxis(writer, axis, u, v);
     writer.Stream()
         << "Focal=\"" << focal << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dArcOfParabola::Restore(Base::XMLReader &reader)
@@ -1931,7 +1930,7 @@
         << "PosY=\"" << Pos.y << "\" "
         << "DirX=\"" << Dir.x << "\" "
         << "DirY=\"" << Dir.y << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dLine::Restore(Base::XMLReader &reader)
@@ -2065,7 +2064,7 @@
         << "StartY=\"" << Start.y << "\" "
         << "EndX=\"" << End.x << "\" "
         << "EndY=\"" << End.y << "\" "
-        << "/>" << endl;
+        << "/>" << std::endl;
 }
 
 void Geom2dLineSegment::Restore(Base::XMLReader &reader)
--- src/Mod/Part/App/Geometry.cpp	2020-06-29 22:29:42.741521637 +0000
+++ ../new/src/Mod/Part/App/Geometry.cpp	2020-06-29 14:22:01.000000000 +0000
@@ -99,10 +99,7 @@
 # include <GeomAPI_ExtremaCurveCurve.hxx>
 # include <ShapeConstruct_Curve.hxx>
 # include <LProp_NotDefined.hxx>
-
-# include <ctime>
-# include <cmath>
-#endif //_PreComp_
+#endif
 
 #include <Base/VectorPy.h>
 #include <Mod/Part/App/LinePy.h>
@@ -138,6 +135,9 @@
 #include <Base/Reader.h>
 #include <Base/Tools.h>
 
+#include <ctime>
+#include <cmath>
+
 #include "Geometry.h"
 
 using namespace Part;
@@ -192,7 +192,6 @@
 
 Geometry::~Geometry()
 {
-
 }
 
 // Persistence implementer
@@ -203,52 +202,16 @@
 
 void Geometry::Save(Base::Writer &writer) const
 {
-    if( extensions.size()>0 ) {
-
-        writer.incInd();
-
-        writer.Stream() << writer.ind() << "<GeoExtensions count=\"" << extensions.size() << "\">" << std::endl;
-
-        for(auto att:extensions) {
-            att->Save(writer);
-        }
-
-        writer.decInd();
-        writer.Stream() << writer.ind() << "</GeoExtensions>" << std::endl;
-    }
-
     const char c = Construction?'1':'0';
     writer.Stream() << writer.ind() << "<Construction value=\"" <<  c << "\"/>" << std::endl;
 }
 
 void Geometry::Restore(Base::XMLReader &reader)
 {
-    reader.readElement();
-
-    if(strcmp(reader.localName(),"GeoExtensions") == 0) {
-
-        int count = reader.getAttributeAsInteger("count");
-
-        for (int i = 0; i < count; i++) {
-            reader.readElement("GeoExtension");
-            const char* TypeName = reader.getAttribute("type");
-            Base::Type type = Base::Type::fromName(TypeName);
-            GeometryExtension *newE = (GeometryExtension *)type.createInstance();
-            newE->Restore(reader);
-
-            extensions.push_back(std::shared_ptr<GeometryExtension>(newE));
-        }
-
-        reader.readEndElement("GeoExtensions");
-
-        reader.readElement("Construction"); // prepare for reading construction attribute
-    }
-    else if(strcmp(reader.localName(),"Construction") != 0) { // ignore anything not known
-        reader.readElement("Construction");
-    }
-
+    // read my Element
+    reader.readElement("Construction");
+    // get the value of my Attribute
     Construction = (int)reader.getAttributeAsInteger("value")==0?false:true;
-
 }
 
 boost::uuids::uuid Geometry::getTag() const
@@ -256,97 +219,6 @@
     return tag;
 }
 
-const std::vector<std::weak_ptr<GeometryExtension>> Geometry::getExtensions() const
-{
-    std::vector<std::weak_ptr<GeometryExtension>> wp;
-
-    for(auto & ext:extensions)
-        wp.push_back(ext);
-
-    return wp;
-}
-
-bool Geometry::hasExtension(Base::Type type) const
-{
-    for( auto ext : extensions) {
-        if(ext->getTypeId() == type)
-            return true;
-    }
-
-    return false;
-}
-
-bool Geometry::hasExtension(std::string name) const
-{
-    for( auto ext : extensions) {
-        if(ext->getName() == name)
-            return true;
-    }
-
-    return false;
-}
-
-const std::weak_ptr<GeometryExtension> Geometry::getExtension(Base::Type type) const
-{
-    for( auto ext : extensions) {
-        if(ext->getTypeId() == type)
-            return ext;
-    }
-
-    throw Base::ValueError("No geometry extension of the requested type.");
-}
-
-const std::weak_ptr<GeometryExtension> Geometry::getExtension(std::string name) const
-{
-    for( auto ext : extensions) {
-        if(ext->getName() == name)
-            return ext;
-    }
-
-    throw Base::ValueError("No geometry extension with the requested name.");
-}
-
-void Geometry::setExtension(std::unique_ptr<GeometryExtension> && geo)
-{
-    bool hasext=false;
-
-    for( auto & ext : extensions) {
-        // if same type and name, this modifies the existing extension.
-        if( ext->getTypeId() == geo->getTypeId() &&
-            ext->getName() == geo->getName()){
-            ext = std::move(geo);
-            hasext = true;
-            break;
-        }
-    }
-
-    if(!hasext) // new type-name unique id, so add.
-        extensions.push_back(std::move(geo));
-}
-
-void Geometry::deleteExtension(Base::Type type)
-{
-    extensions.erase(
-        std::remove_if( extensions.begin(),
-                        extensions.end(),
-                        [&type](const std::shared_ptr<GeometryExtension>& ext){
-                            return ext->getTypeId() == type;
-                        }),
-        extensions.end());
-}
-
-void Geometry::deleteExtension(std::string name)
-{
-    extensions.erase(
-        std::remove_if( extensions.begin(),
-                        extensions.end(),
-                        [&name](const std::shared_ptr<GeometryExtension>& ext){
-                            return ext->getName() == name;
-                        }),
-        extensions.end());
-}
-
-
 void Geometry::createNewTag()
 {
     // Initialize a random number generator, to avoid Valgrind false positives.
@@ -374,10 +246,6 @@
 {
     Geometry* cpy = this->copy();
     cpy->tag = this->tag;
-
-    for(auto & ext: extensions)
-        cpy->extensions.push_back(ext->copy());
-
     return cpy;
 }
 
@@ -888,7 +756,7 @@
 
     for (Standard_Integer i=p.Lower(); i<=p.Upper(); i++) {
         const gp_Pnt& pnt = p(i);
-        poles.emplace_back(pnt.X(), pnt.Y(), pnt.Z());
+        poles.push_back(Base::Vector3d(pnt.X(), pnt.Y(), pnt.Z()));
     }
     return poles;
 }
@@ -1122,7 +990,7 @@
 
     for (Standard_Integer i=p.Lower(); i<=p.Upper(); i++) {
         const gp_Pnt& pnt = p(i);
-        poles.emplace_back(pnt.X(), pnt.Y(), pnt.Z());
+        poles.push_back(Base::Vector3d(pnt.X(), pnt.Y(), pnt.Z()));
     }
     return poles;
 }
@@ -3884,13 +3752,7 @@
         // the points are too close. The best try to restore is incrementing the distance.
         // for other objects, the best effort may be just to leave default values.
         reader.setPartialRestore(true);
-
-        if(start.x == 0) {
-            end = start + Base::Vector3d(DBL_EPSILON,0,0);
-        }
-        else {
-            end = start + Base::Vector3d(start.x*DBL_EPSILON,0,0);
-        }
+        end = start + Base::Vector3d(start.x*DBL_EPSILON,0,0);
 
         setPoints(start, end);
     }
--- src/Mod/Part/App/PropertyTopoShape.cpp	2020-06-29 22:29:42.753515637 +0000
+++ ../new/src/Mod/Part/App/PropertyTopoShape.cpp	2020-06-29 14:13:03.000000000 +0000
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (c) 2002 Jürgen Riegel <juergen.riegel@web.de>              *
+ *   Copyright (c) Jürgen Riegel          (juergen.riegel@web.de) 2002     *
  *                                                                         *
  *   This file is part of the FreeCAD CAx development system.              *
  *                                                                         *
@@ -42,13 +42,12 @@
 # include <Standard_Version.hxx>
 # include <gp_GTrsf.hxx>
 # include <gp_Trsf.hxx>
+#endif
 
 #if OCC_VERSION_HEX >= 0x060800
-# include <OSD_OpenFile.hxx>
+#include <OSD_OpenFile.hxx>
 #endif
 
-#endif // _PreComp_
-
 #include <Base/Console.h>
 #include <Base/Writer.h>
 #include <Base/Reader.h>
@@ -72,7 +71,7 @@
 
 using namespace Part;
 
-TYPESYSTEM_SOURCE(Part::PropertyPartShape , App::PropertyComplexGeoData)
+TYPESYSTEM_SOURCE(Part::PropertyPartShape , App::PropertyComplexGeoData);
 
 PropertyPartShape::PropertyPartShape()
 {
@@ -96,7 +95,7 @@
     hasSetValue();
 }
 
-const TopoDS_Shape& PropertyPartShape::getValue(void)const
+const TopoDS_Shape& PropertyPartShape::getValue(void)const 
 {
     return _Shape.getShape();
 }
@@ -186,7 +185,7 @@
         }
     }
 
-    prop->setConst();
+    if (prop) prop->setConst();
     return prop;
 }
 
@@ -246,12 +245,12 @@
     if(!writer.isForceXML()) {
         //See SaveDocFile(), RestoreDocFile()
         if (writer.getMode("BinaryBrep")) {
-            writer.Stream() << writer.ind() << "<Part file=\""
+            writer.Stream() << writer.ind() << "<Part file=\"" 
                             << writer.addFile("PartShape.bin", this)
                             << "\"/>" << std::endl;
         }
         else {
-            writer.Stream() << writer.ind() << "<Part file=\""
+            writer.Stream() << writer.ind() << "<Part file=\"" 
                             << writer.addFile("PartShape.brp", this)
                             << "\"/>" << std::endl;
         }
@@ -279,25 +278,25 @@
   SS.Write(S);
   SS.Write(Sh,S);
 }
-
-static Standard_Boolean  BRepTools_Write(const TopoDS_Shape& Sh, const Standard_CString File)
+static Standard_Boolean  BRepTools_Write(const TopoDS_Shape& Sh, 
+                                   const Standard_CString File)
 {
   std::ofstream os;
 #if OCC_VERSION_HEX >= 0x060800
   OSD_OpenStream(os, File, std::ios::out);
 #else
-  os.open(File, std::ios::out);
+  os.open(File, ios::out);
 #endif
   if (!os.rdbuf()->is_open()) return Standard_False;
 
   Standard_Boolean isGood = (os.good() && !os.eof());
   if(!isGood)
     return isGood;
-
+  
   BRepTools_ShapeSet SS(Standard_False);
   // SS.SetProgress(PR);
   SS.Add(Sh);
-
+  
   os << "DBRep_DrawableShape\n";  // for easy Draw read
   SS.Write(os);
   isGood = os.good();
@@ -342,7 +341,7 @@
                 App::PropertyContainer* father = this->getContainer();
                 if (father && father->isDerivedFrom(App::DocumentObject::getClassTypeId())) {
                     App::DocumentObject* obj = static_cast<App::DocumentObject*>(father);
-                    Base::Console().Error("Shape of '%s' cannot be written to BRep file '%s'\n",
+                    Base::Console().Error("Shape of '%s' cannot be written to BRep file '%s'\n", 
                         obj->Label.getValue(),fi.filePath().c_str());
                 }
                 else {
@@ -356,7 +355,7 @@
 
             Base::ifstream file(fi, std::ios::in | std::ios::binary);
             if (file) {
-                //unsigned long ulSize = 0;
+                //unsigned long ulSize = 0; 
                 std::streambuf* buf = file.rdbuf();
                 //if (buf) {
                 //    unsigned long ulCurr;
@@ -400,7 +399,7 @@
 
             // read in the ASCII file and write back to the file stream
             Base::ofstream file(fi, std::ios::out | std::ios::binary);
-            unsigned long ulSize = 0;
+            unsigned long ulSize = 0; 
             if (reader) {
                 std::streambuf* buf = file.rdbuf();
                 reader >> buf;
@@ -421,7 +420,7 @@
                     App::PropertyContainer* father = this->getContainer();
                     if (father && father->isDerivedFrom(App::DocumentObject::getClassTypeId())) {
                         App::DocumentObject* obj = static_cast<App::DocumentObject*>(father);
-                        Base::Console().Error("BRep file '%s' with shape of '%s' seems to be empty\n",
+                        Base::Console().Error("BRep file '%s' with shape of '%s' seems to be empty\n", 
                             fi.filePath().c_str(),obj->Label.getValue());
                     }
                     else {
@@ -445,7 +444,7 @@
 
 // -------------------------------------------------------------------------
 
-TYPESYSTEM_SOURCE(Part::PropertyShapeHistory , App::PropertyLists)
+TYPESYSTEM_SOURCE(Part::PropertyShapeHistory , App::PropertyLists);
 
 PropertyShapeHistory::PropertyShapeHistory()
 {
@@ -511,7 +510,7 @@
 
 // -------------------------------------------------------------------------
 
-TYPESYSTEM_SOURCE(Part::PropertyFilletEdges , App::PropertyLists)
+TYPESYSTEM_SOURCE(Part::PropertyFilletEdges , App::PropertyLists);
 
 PropertyFilletEdges::PropertyFilletEdges()
 {
--- src/Mod/Drawing/App/DrawingExport.cpp	2020-06-29 22:29:42.017883637 +0000
+++ ../new/src/Mod/Drawing/App/DrawingExport.cpp	2020-06-29 14:50:42.000000000 +0000
@@ -81,7 +81,6 @@
 #include <Base/Vector3D.h>
 
 using namespace Drawing;
-using namespace std;
 
 TopoDS_Edge DrawingOutput::asCircle(const BRepAdaptor_Curve& c) const
 {
@@ -435,7 +434,7 @@
             out << c << " " << nodes(i).X() << " " << nodes(i).Y()<< " " ; 
             c = 'L';
         }
-        out << "\" />" << endl;
+        out << "\" />" << std::endl;
     } else if (c.GetType() == GeomAbs_Line) {
         //BRep_Tool::Polygon3D assumes the edge has polygon representation - ie already been "tessellated"
         //this is not true for all edges, especially "floating edges"
@@ -448,7 +447,7 @@
         out << c << " " << s.X() << " " << s.Y()<< " " ; 
         c = 'L';
         out << c << " " << e.X() << " " << e.Y()<< " " ; 
-        out << "\" />" << endl;
+        out << "\" />" << std::endl;
     }
 }
 
@@ -486,10 +485,10 @@
 
 void DXFOutput::printHeader( std::ostream& out)
 {
-        out	 << 0          << endl;
-        out << "SECTION"  << endl;
-        out << 2          << endl;
-        out << "ENTITIES" << endl;
+        out	 << 0          << std::endl;
+        out << "SECTION"  << std::endl;
+        out << 2          << std::endl;
+        out << "ENTITIES" << std::endl;
 }
 
 void DXFOutput::printCircle(const BRepAdaptor_Curve& c, std::ostream& out)
@@ -513,22 +512,22 @@
     if (s.SquareDistance(e) < 0.001) {
         //out << "<circle cx =\"" << p.X() << "\" cy =\"" 
             //<< p.Y() << "\" r =\"" << r << "\" />";
-	    out << 0			<< endl;
-	    out << "CIRCLE"		<< endl;
-	    out << 8			<< endl;	// Group code for layer name
-	    out << "sheet_layer"	<< endl;	// Layer number
-        out << "100"        << endl;
-        out << "AcDbEntity" << endl;
-        out << "100"        << endl;
-        out << "AcDbCircle"   << endl;
-	    out << 10			<< endl;	// Centre X
-	    out << p.X()		<< endl;	// X in WCS coordinates
-	    out << 20			<< endl;
-	    out << p.Y()		<< endl;	// Y in WCS coordinates
-	    out << 30			<< endl;
-	    out << 0		<< endl;	// Z in WCS coordinates-leaving flat
-	    out << 40			<< endl;	//
-	    out << r		<< endl;	// Radius
+	    out << 0			<< std::endl;
+	    out << "CIRCLE"		<< std::endl;
+	    out << 8			<< std::endl;	// Group code for layer name
+	    out << "sheet_layer"	<< std::endl;	// Layer number
+        out << "100"        << std::endl;
+        out << "AcDbEntity" << std::endl;
+        out << "100"        << std::endl;
+        out << "AcDbCircle"   << std::endl;
+	    out << 10			<< std::endl;	// Centre X
+	    out << p.X()		<< std::endl;	// X in WCS coordinates
+	    out << 20			<< std::endl;
+	    out << p.Y()		<< std::endl;	// Y in WCS coordinates
+	    out << 30			<< std::endl;
+	    out << 0		<< std::endl;	// Z in WCS coordinates-leaving flat
+	    out << 40			<< std::endl;	//
+	    out << r		<< std::endl;	// Radius
                                 }
 
 
@@ -556,28 +555,28 @@
 		double temp = start_angle;
 		start_angle = end_angle;
 		end_angle = temp;}
-	out << 0			<< endl;
-	out << "ARC"		<< endl;
-	out << 8			<< endl;	// Group code for layer name
-	out << "sheet_layer"	<< endl;	// Layer number
-    out << "100"        << endl;
-    out << "AcDbEntity" << endl;
-    out << "100"        << endl;
-    out << "AcDbCircle" << endl;
-	out << 10			<< endl;	// Centre X
-	out << p.X()		<< endl;	// X in WCS coordinates
-	out << 20			<< endl;
-	out << p.Y()		<< endl;	// Y in WCS coordinates
-	out << 30			<< endl;
-	out << 0		<< endl;	// Z in WCS coordinates
-	out << 40			<< endl;	//
-	out << r		<< endl;	// Radius
-    out << "100"        << endl;
-    out << "AcDbArc" << endl;
-	out << 50			<< endl;
-	out << start_angle	<< endl;	// Start angle
-	out << 51			<< endl;
-	out << end_angle	<< endl;	// End angle
+	out << 0			<< std::endl;
+	out << "ARC"		<< std::endl;
+	out << 8			<< std::endl;	// Group code for layer name
+	out << "sheet_layer"	<< std::endl;	// Layer number
+    out << "100"        << std::endl;
+    out << "AcDbEntity" << std::endl;
+    out << "100"        << std::endl;
+    out << "AcDbCircle" << std::endl;
+	out << 10			<< std::endl;	// Centre X
+	out << p.X()		<< std::endl;	// X in WCS coordinates
+	out << 20			<< std::endl;
+	out << p.Y()		<< std::endl;	// Y in WCS coordinates
+	out << 30			<< std::endl;
+	out << 0		<< std::endl;	// Z in WCS coordinates
+	out << 40			<< std::endl;	//
+	out << r		<< std::endl;	// Radius
+    out << "100"        << std::endl;
+    out << "AcDbArc" << std::endl;
+	out << 50			<< std::endl;
+	out << start_angle	<< std::endl;	// Start angle
+	out << 51			<< std::endl;
+	out << end_angle	<< std::endl;	// End angle
 
 
 
@@ -629,32 +628,32 @@
 		start_angle = end_angle;
 		end_angle = temp;
 	}
-	out << 0			<< endl;
-	out << "ELLIPSE"		<< endl;
-	out << 8			<< endl;	// Group code for layer name
-	out << "sheet_layer"	<< endl;	// Layer number
-    out << "100"        << endl;
-    out << "AcDbEntity" << endl;
-    out << "100"        << endl;
-    out << "AcDbEllipse"   << endl;
-	out << 10			<< endl;	// Centre X
-	out << p.X()		<< endl;	// X in WCS coordinates
-	out << 20			<< endl;
-	out << p.Y()		<< endl;	// Y in WCS coordinates
-	out << 30			<< endl;
-	out << 0		<< endl;	// Z in WCS coordinates
-	out << 11			<< endl;	//
-	out << major_x		<< endl;	// Major X
-	out << 21			<< endl;
-	out << major_y		<< endl;	// Major Y
-	out << 31			<< endl;
-	out << 0		<< endl;	// Major Z
-	out << 40			<< endl;	//
-	out << ratio		<< endl;	// Ratio
-	out << 41		<< endl;
-	out << start_angle	<< endl;	// Start angle
-	out << 42		<< endl;
-	out << end_angle	<< endl;	// End angle
+	out << 0			<< std::endl;
+	out << "ELLIPSE"		<< std::endl;
+	out << 8			<< std::endl;	// Group code for layer name
+	out << "sheet_layer"	<< std::endl;	// Layer number
+    out << "100"        << std::endl;
+    out << "AcDbEntity" << std::endl;
+    out << "100"        << std::endl;
+    out << "AcDbEllipse"   << std::endl;
+	out << 10			<< std::endl;	// Centre X
+	out << p.X()		<< std::endl;	// X in WCS coordinates
+	out << 20			<< std::endl;
+	out << p.Y()		<< std::endl;	// Y in WCS coordinates
+	out << 30			<< std::endl;
+	out << 0		<< std::endl;	// Z in WCS coordinates
+	out << 11			<< std::endl;	//
+	out << major_x		<< std::endl;	// Major X
+	out << 21			<< std::endl;
+	out << major_y		<< std::endl;	// Major Y
+	out << 31			<< std::endl;
+	out << 0		<< std::endl;	// Major Z
+	out << 40			<< std::endl;	//
+	out << ratio		<< std::endl;	// Ratio
+	out << 41		<< std::endl;
+	out << start_angle	<< std::endl;	// Start angle
+	out << 42		<< std::endl;
+	out << end_angle	<< std::endl;	// End angle
 }
 
 void DXFOutput::printBSpline(const BRepAdaptor_Curve& c, int id, std::ostream& out) //Not even close yet- DF 
@@ -693,31 +692,31 @@
         spline->Poles(poles);
 
 
-        str << 0 << endl
-            << "SPLINE" << endl
-            << 8 << endl // Group code for layer name
-            << "sheet_layer" << endl // Layer name
-            << "100"        << endl
-            << "AcDbEntity" << endl
-            << "100"        << endl
-            << "AcDbSpline"   << endl
-            << 70 << endl
-            << spline->IsRational()*4 << endl //flags
-            << 71 << endl << spline->Degree() << endl
-            << 72 << endl << knotsequence.Length() << endl
-            << 73 << endl << poles.Length() << endl
-            << 74 << endl << 0 << endl; //fitpoints
+        str << 0 << std::endl
+            << "SPLINE" << std::endl
+            << 8 << std::endl // Group code for layer name
+            << "sheet_layer" << std::endl // Layer name
+            << "100"        << std::endl
+            << "AcDbEntity" << std::endl
+            << "100"        << std::endl
+            << "AcDbSpline"   << std::endl
+            << 70 << std::endl
+            << spline->IsRational()*4 << std::endl //flags
+            << 71 << std::endl << spline->Degree() << std::endl
+            << 72 << std::endl << knotsequence.Length() << std::endl
+            << 73 << std::endl << poles.Length() << std::endl
+            << 74 << std::endl << 0 << std::endl; //fitpoints
 
         for (int i = knotsequence.Lower() ; i <= knotsequence.Upper(); i++) {
-            str << 40 << endl << knotsequence(i) << endl;
+            str << 40 << std::endl << knotsequence(i) << std::endl;
         }
         for (int i = poles.Lower(); i <= poles.Upper(); i++) {
             gp_Pnt pole = poles(i);
-            str << 10 << endl << pole.X() << endl
-                << 20 << endl << pole.Y() << endl
-                << 30 << endl << pole.Z() << endl;
+            str << 10 << std::endl << pole.X() << std::endl
+                << 20 << std::endl << pole.Y() << std::endl
+                << 30 << std::endl << pole.Z() << std::endl;
             if (spline->IsRational()) {
-                str << 41 << endl << spline->Weight(i) << endl;
+                str << 41 << std::endl << spline->Weight(i) << std::endl;
             }
         }
 
@@ -741,24 +740,24 @@
     gp_Vec VE;
     c.D1(uEnd, PE, VE);
 
-    out << "0"			<< endl;
-    out << "LINE"		<< endl;
-    out << "8"			<< endl;	// Group code for layer name
-    out << "sheet_layer" << endl; // Layer name 
-    out << "100"        << endl;
-    out << "AcDbEntity" << endl;
-    out << "100"        << endl;
-    out << "AcDbLine"   << endl;
-    out << "10"			<< endl;	// Start point of line
-    out << PS.X()		<< endl;	// X in WCS coordinates
-    out << "20"			<< endl;
-    out << PS.Y()		<< endl;	// Y in WCS coordinates
-    out << "30"			<< endl;
-    out << "0"		<< endl;	// Z in WCS coordinates
-    out << "11"			<< endl;	// End point of line
-    out << PE.X()		<< endl;	// X in WCS coordinates
-    out << "21"			<< endl;
-    out << PE.Y()		<< endl;	// Y in WCS coordinates
-    out << "31"			<< endl;
-    out << "0"		<< endl;	// Z in WCS coordinates
+    out << "0"			<< std::endl;
+    out << "LINE"		<< std::endl;
+    out << "8"			<< std::endl;	// Group code for layer name
+    out << "sheet_layer" << std::endl; // Layer name 
+    out << "100"        << std::endl;
+    out << "AcDbEntity" << std::endl;
+    out << "100"        << std::endl;
+    out << "AcDbLine"   << std::endl;
+    out << "10"			<< std::endl;	// Start point of line
+    out << PS.X()		<< std::endl;	// X in WCS coordinates
+    out << "20"			<< std::endl;
+    out << PS.Y()		<< std::endl;	// Y in WCS coordinates
+    out << "30"			<< std::endl;
+    out << "0"		<< std::endl;	// Z in WCS coordinates
+    out << "11"			<< std::endl;	// End point of line
+    out << PE.X()		<< std::endl;	// X in WCS coordinates
+    out << "21"			<< std::endl;
+    out << PE.Y()		<< std::endl;	// Y in WCS coordinates
+    out << "31"			<< std::endl;
+    out << "0"		<< std::endl;	// Z in WCS coordinates
 }
--- src/Mod/Raytracing/App/LuxFeature.cpp	2020-06-29 22:29:43.297243637 +0000
+++ ../new/src/Mod/Raytracing/App/LuxFeature.cpp	2020-06-29 14:51:28.000000000 +0000
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (c) 2013 Yorik van Havre <yorik@uncreated.net>              *
+ *   Copyright (c) Yorik van Havre          (yorik@uncreated.net) 2013     *
  *                                                                         *
  *   This file is part of the FreeCAD CAx development system.              *
  *                                                                         *
@@ -38,7 +38,6 @@
 
 
 using namespace Raytracing;
-using namespace std;
 
 PROPERTY_SOURCE(Raytracing::LuxFeature, Raytracing::RaySegment)
 
@@ -89,23 +88,23 @@
     const App::Color& c = Color.getValue();
     long t = Transparency.getValue();
     if (t == 0) {
-        result << "MakeNamedMaterial \"FreeCADMaterial_" << Name << "\"" << endl
-               << "    \"color Kd\" [" << c.r << " " << c.g << " " << c.b << "]" << endl
-               << "    \"float sigma\" [0.000000000000000]" << endl
-               << "    \"string type\" [\"matte\"]" << endl << endl;
+        result << "MakeNamedMaterial \"FreeCADMaterial_" << Name << "\"" << std::endl
+               << "    \"color Kd\" [" << c.r << " " << c.g << " " << c.b << "]" << std::endl
+               << "    \"float sigma\" [0.000000000000000]" << std::endl
+               << "    \"string type\" [\"matte\"]" << std::endl << std::endl;
     } else {
         float trans = t/100.0f;
-        result << "MakeNamedMaterial \"FreeCADMaterial_Base_" << Name << "\"" << endl
-               << "    \"color Kd\" [" << c.r << " " << c.g << " " << c.b << "]" << endl
-               << "    \"float sigma\" [0.000000000000000]" << endl
-               << "    \"string type\" [\"matte\"]" << endl << endl
-               << "MakeNamedMaterial \"FreeCADMaterial_Null_" << Name << "\"" << endl
-               << "    \"string type\" [\"null\"]" << endl << endl
-               << "MakeNamedMaterial \"FreeCADMaterial_" << Name << "\"" << endl
-               << "    \"string namedmaterial1\" [\"FreeCADMaterial_Null_" << Name << "\"]" << endl
-               << "    \"string namedmaterial2\" [\"FreeCADMaterial_Base_" << Name << "\"]" << endl
-               << "    \"float amount\" [" << trans << "]" << endl
-               << "    \"string type\" [\"mix\"]" << endl << endl;
+        result << "MakeNamedMaterial \"FreeCADMaterial_Base_" << Name << "\"" << std::endl
+               << "    \"color Kd\" [" << c.r << " " << c.g << " " << c.b << "]" << std::endl
+               << "    \"float sigma\" [0.000000000000000]" << std::endl
+               << "    \"string type\" [\"matte\"]" << std::endl << std::endl
+               << "MakeNamedMaterial \"FreeCADMaterial_Null_" << Name << "\"" << std::endl
+               << "    \"string type\" [\"null\"]" << std::endl << std::endl
+               << "MakeNamedMaterial \"FreeCADMaterial_" << Name << "\"" << std::endl
+               << "    \"string namedmaterial1\" [\"FreeCADMaterial_Null_" << Name << "\"]" << std::endl
+               << "    \"string namedmaterial2\" [\"FreeCADMaterial_Base_" << Name << "\"]" << std::endl
+               << "    \"float amount\" [" << trans << "]" << std::endl
+               << "    \"string type\" [\"mix\"]" << std::endl << std::endl;
     }
     
     LuxTools::writeShape(result,Name.c_str(),shape);
--- src/Mod/Raytracing/App/RayFeature.cpp	2020-06-29 22:29:43.297243637 +0000
+++ ../new/src/Mod/Raytracing/App/RayFeature.cpp	2020-06-29 14:46:28.000000000 +0000
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (c) 2002 Jürgen Riegel <juergen.riegel@web.de>              *
+ *   Copyright (c) Jürgen Riegel          (juergen.riegel@web.de) 2002     *
  *                                                                         *
  *   This file is part of the FreeCAD CAx development system.              *
  *                                                                         *
@@ -36,7 +36,6 @@
 
 
 using namespace Raytracing;
-using namespace std;
 
 PROPERTY_SOURCE(Raytracing::RayFeature, Raytracing::RaySegment)
 
@@ -82,19 +81,19 @@
     // This must not be done in PovTools::writeShape!
     long t = Transparency.getValue();
     const App::Color& c = Color.getValue();
-    result << "// instance to render" << endl
-           << "object {" << Name << endl
-           << " texture {" << endl;
+    result << "// instance to render" << std::endl
+           << "object {" << Name << std::endl
+           << " texture {" << std::endl;
     if (t == 0) {
-        result << "      pigment {color rgb <"<<c.r<<","<<c.g<<","<<c.b<<">}" << endl;
+        result << "      pigment {color rgb <"<<c.r<<","<<c.g<<","<<c.b<<">}" << std::endl;
     }
     else {
         float trans = t/100.0f;
-        result << "      pigment {color rgb <"<<c.r<<","<<c.g<<","<<c.b<<"> transmit "<<trans<<"}" << endl;
+        result << "      pigment {color rgb <"<<c.r<<","<<c.g<<","<<c.b<<"> transmit "<<trans<<"}" << std::endl;
     }
-    result << "      finish {StdFinish } //definition on top of the project" << endl
-           << "  }" << endl
-           << "}" << endl   ;
+    result << "      finish {StdFinish } //definition on top of the project" << std::endl
+           << "  }" << std::endl
+           << "}" << std::endl   ;
 
     // Apply the resulting fragment
     Result.setValue(result.str().c_str());
--- src/Mod/Raytracing/App/AppRaytracingPy.cpp	2020-06-29 22:29:43.297243637 +0000
+++ ../new/src/Mod/Raytracing/App/AppRaytracingPy.cpp	2020-06-29 14:35:26.000000000 +0000
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (c) Jürgen Riegel <juergen.riegel@web.de>                   *
+ *   Copyright (c) Juergen Riegel         <juergen.riegel@web.de>          *
  *                                                                         *
  *   This file is part of the FreeCAD CAx development system.              *
  *                                                                         *
@@ -40,8 +40,6 @@
 #include <Mod/Part/App/TopoShapePy.h>
 #include <App/Application.h>
 
-using namespace std;
-
 
 namespace Raytracing {
 class Module : public Py::ExtensionModule<Module>
@@ -107,13 +105,13 @@
 
         PovTools::writeShape(out,PartName,aShape,(float)0.1);
         // This must not be done in PovTools::writeShape!
-        out << "// instance to render" << endl
-            << "object {" << PartName << endl
-            << "  texture {" << endl
-            << "      pigment {color rgb <"<<r<<","<<g<<","<<b<<">}" << endl
-            << "      finish {StdFinish } //definition on top of the project" << endl
-            << "  }" << endl
-            << "}" << endl   ;
+        out << "// instance to render" << std::endl
+            << "object {" << PartName << std::endl
+            << "  texture {" << std::endl
+            << "      pigment {color rgb <"<<r<<","<<g<<","<<b<<">}" << std::endl
+            << "      finish {StdFinish } //definition on top of the project" << std::endl
+            << "  }" << std::endl
+            << "}" << std::endl   ;
         return Py::String(out.str());
     }
     Py::Object getPartAsLux(const Py::Tuple& args)
@@ -130,10 +128,10 @@
 
         // write a material entry
         // This must not be done in PovTools::writeShape!
-        out << "MakeNamedMaterial \"FreeCADMaterial_" << PartName << "\"" << endl;
-        out << "    \"color Kd\" [" << r << " " << g << " " << b << "]" << endl;
-        out << "    \"float sigma\" [0.000000000000000]" << endl;
-        out << "    \"string type\" [\"matte\"]" << endl << endl;
+        out << "MakeNamedMaterial \"FreeCADMaterial_" << PartName << "\"" << std::endl;
+        out << "    \"color Kd\" [" << r << " " << g << " " << b << "]" << std::endl;
+        out << "    \"float sigma\" [0.000000000000000]" << std::endl;
+        out << "    \"string type\" [\"matte\"]" << std::endl << std::endl;
 
         LuxTools::writeShape(out,PartName,aShape,(float)0.1);
         return Py::String(out.str());
